import asyncio
from typing import Dict
from aiogram import Bot, Dispatcher, executor, types
from aiogram.types import InlineKeyboardButton
from aiohttp import ClientSession
import user_queue
import pickle

BOT_CREATOR = 751586125
with open("queues.txt", "rb") as f:
    queues = pickle.load(f)

CAN_CREATE_QUEUES = {
    751586125: user_queue.Admin(751586125, "Hu Tao", "Hu Tao"),
    731492287: user_queue.Admin(731492287, "Masha", "ü•∞ü•∞—Å—Ç–∞—Ä–æ—Å—Ç–∞ü•∞ü•∞"),
    406495448: user_queue.Admin(406495448, "Egor", "–ó–ª–æ–±–Ω—ã–π –∫–ª–æ—É–Ω"),
    656638834: user_queue.Admin(656638834, "Vika Nemolyaeva", "Lisa Malyaeva"),
    409428213: user_queue.Admin(409428213, "Sergey Papikyan", "Ser Gey Papik(yan)"),
    433013981: user_queue.Admin(433013981, "Danya", "–°–∞—Ö–∞—Ä–Ω—ã–π —á–µ–ª–æ–≤–µ–∫ üç≠"),
}
CHAT_IDS = {-1001584422120: "03—É26", -1001602645423: "04—É26"}

queues: Dict[int, Dict[int, user_queue.Queue]] = queues
CAN_CREATE_QUEUES: Dict[int, user_queue.Admin] = CAN_CREATE_QUEUES

file = open('token.txt', 'r')
API_TOKEN = file.read()
file.close()

file = open('gtoken.txt', 'r')
URL_TEMPLATE = f"https://sheets.googleapis.com/v4/spreadsheets/" \
      f"1RDy1Fs8YmFQ7siXtub1wGKU5nnHTwHn6soBA4FvtPno/values/" \
      f"–û—á–µ—Ä–µ–¥—å (TEMPLATE)!A:C?" \
      f"key={file.read().strip()}"
URLS = {}
URLS[-1001584422120] = URL_TEMPLATE.replace("TEMPLATE", "03")
URLS[-1001602645423] = URL_TEMPLATE.replace("TEMPLATE", "04")
file.close()

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)


@dp.message_handler(commands=["myid"])
async def my_id(message: types.Message):
    ans = f"Your id: ***`{message.from_user.id}`***\nThis chat id: ***`{message.chat.id}`***"
    if message.chat.id in CHAT_IDS.keys():
        ans += f" \\(defined as {CHAT_IDS[message.chat.id]}\\)"
    if message.from_user.id in CAN_CREATE_QUEUES.keys():
        ans += f"\nYou can create queues"
    await message.answer(ans, parse_mode="MarkdownV2")


@dp.message_handler(commands=["createq", "createqueue", "startq", "startqueue"])
async def create_queue(message: types.Message):
    if message.from_user.id not in CAN_CREATE_QUEUES:
        await message.answer("–¢—ã –Ω–µ –º–æ–∂–µ—à—å —Å–æ–∑–¥–∞—Ç—å –æ—á–µ—Ä–µ–¥—å")
        return
    if len(message.text.split()) < 2:
        await message.answer("Usage: /createqueue <size, default=25> <qname>")
        return
    try:
        size = min(int(message.text.split()[1]), 98)
        _, qname = message.text.split(maxsplit=2)[1:]
    except ValueError:
        qname = message.text.split(maxsplit=1)[1]
        size = 25

    if message.chat.id not in queues.keys():
        queues[message.chat.id] = {}

    if qname in queues[message.chat.id].keys():
        await message.answer("–≠—Ç–∞ –æ—á–µ—Ä–µ–¥—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
        return
    if '/' in qname:
        await message.answer("–ù–µ –¥–æ–±–∞–≤–ª—è–π / –≤ –Ω–∞–∑–≤–∞–Ω–∏–µ –æ—á–µ—Ä–µ–¥–∏")
        return
    if len(qname) > 30:
        await message.answer("–°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ")
        return

    buttons = [InlineKeyboardButton(str(num) + "üü¢", callback_data=f"key/{num - 1}/{qname}") for num in range(1, size + 1)]
    reset_button = InlineKeyboardButton("RESET", callback_data=f"reset/{qname}")
    stop_button = InlineKeyboardButton("STOP", callback_data=f"stop/{qname}")
    queues[message.chat.id][qname] = user_queue.Queue(message.from_user.id, [buttons, reset_button, stop_button], size=size)
    await message.answer(f"{qname}:\n{queues[message.chat.id][qname].get_print()} \n(Generated by {CAN_CREATE_QUEUES[message.from_user.id].description})", reply_markup=queues[message.chat.id][qname].get_keyboard())


@dp.message_handler(commands=["getqueue"])
async def get_queue_from_google(message: types.Message):
    if message.from_user.id not in CAN_CREATE_QUEUES:
        await message.answer("–¢—ã –Ω–µ –º–æ–∂–µ—à—å —Å–æ–∑–¥–∞—Ç—å –æ—á–µ—Ä–µ–¥—å")
        return
    if message.chat.id not in URLS.keys():
        await message.answer("–≠—Ç–æ—Ç —á–∞—Ç –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω")
        return
    msg = "–ò–∑ —Ç–∞–±–ª–∏—á–∫–∏:\n"
    async with ClientSession() as session:
        async with session.get(URLS[message.chat.id]) as response:
            values = await response.json()

            for name, _, labwork_id in values.get("values")[1:]:
                msg += f"{labwork_id: <3} {name}\n"

    await message.answer(text=msg)


@dp.message_handler(commands=["delaystartq"])
async def delay_create_queue(message: types.Message):
    if message.text < 2:
        await message.answer("Usage: /delaystartq t=<await time> <delay, default=10> <qname>")
        return
    time = 10
    if message.text.split()[1].startswith('t='):
        time = int(message.text.split()[1][2:])
        if time % 10 != 0:
            time -= time % 10 - 10
        message.text = message.text.replace(message.text.split()[1] + " ", "")

    start_time = time

    callback_query = await message.answer(f"–û—á–µ—Ä–µ–¥—å –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è —á–µ—Ä–µ–∑ {time} —Å–µ–∫")
    while time != 0:
        time -= 10
        await asyncio.sleep(10)
        await bot.edit_message_text(message_id=callback_query.message_id, chat_id=callback_query.chat.id, text=f"–û—á–µ—Ä–µ–¥—å –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è —á–µ—Ä–µ–∑ {time} (start={start_time}) —Å–µ–∫")
    await create_queue(message)
    await bot.edit_message_text(message_id=callback_query.message_id, chat_id=callback_query.chat.id, text=f"–û—á–µ—Ä–µ–¥—å –∑–∞–ø—É—â–µ–Ω–∞!")


@dp.message_handler(commands=["listq"])
async def queue_list(message: types.Message):
    if message.from_user.id != BOT_CREATOR:
        await message.answer("Only for Hu Tao")
        return

    msg = "–û—á–µ—Ä–µ–¥–∏:\n"
    for (chat_id, queues_list) in queues.items():
        msg += f"{CHAT_IDS.get(chat_id, chat_id)}:\n"
        for name in queues_list.keys():
            msg += f"{name}\n"
        msg += "\n"

    await message.answer(text=msg)


@dp.message_handler(commands=["delete"])
async def delete_all(message: types.Message):
    if message.from_user.id != BOT_CREATOR:
        await message.answer("Only for Hu Tao")
        return

    for i in list(queues[message.chat.id].keys()):
        del queues[message.chat.id][i]
    await message.answer(text="Done")


@dp.message_handler(commands=["deleteall"])
async def delete_all(message: types.Message):
    if message.from_user.id != BOT_CREATOR:
        await message.answer("Only for Hu Tao")
        return

    for i in list(queues.keys()):
        del queues[i]
    await message.answer(text="Done")


@dp.message_handler(commands=["shutdown", "exit"])
async def shutdown(message: types.Message):
    if message.from_user.id != BOT_CREATOR:
        await message.answer("Only for Hu Tao")
        return

    dp.stop_polling()
    pickle.dump(queues, open("queues.txt", "wb"))
    exit()


@dp.callback_query_handler(lambda c: c.data and c.data.startswith('key'))
async def insert_in_queue(callback_query: types.CallbackQuery):
    _, code, qname = callback_query.data.split("/")
    code = int(code)
    user_id = callback_query.from_user.id
    name = f"{callback_query.from_user.full_name} (@{callback_query.from_user.username})"
    text, code = queues[callback_query.message.chat.id][qname].set(code, user_id, name)
    await bot.answer_callback_query(callback_query.id, text=text)
    if code:
        await bot.edit_message_text(message_id=callback_query.message.message_id,
                                    chat_id=callback_query.message.chat.id,
                                    text=f"{qname}:\n{queues[callback_query.message.chat.id][qname].get_print()} \n\
                                    (Generated by {CAN_CREATE_QUEUES[queues[callback_query.message.chat.id][qname].creator].description})",
                                    reply_markup=queues[callback_query.message.chat.id][qname].get_keyboard())


@dp.callback_query_handler(lambda c: c.data and c.data.startswith("stop"))
async def delete_queue(callback_query: types.CallbackQuery):
    _, qname = callback_query.data.split("/")
    if qname not in queues[callback_query.message.chat.id].keys():
        await bot.edit_message_text(message_id=callback_query.message.message_id,
                                    chat_id=callback_query.message.chat.id,
                                    text=f"{qname} (stopped)")
        return

    if callback_query.from_user.id != queues[callback_query.message.chat.id][qname].creator and callback_query.from_user.id != BOT_CREATOR:
        await bot.answer_callback_query(callback_query.id, text="–≠—Ç–æ –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å —Ç–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å –æ—á–µ—Ä–µ–¥–∏")
        return

    await bot.edit_message_text(message_id=callback_query.message.message_id, chat_id=callback_query.message.chat.id, text=f"{qname} (stopped):\n{queues[callback_query.message.chat.id][qname].get_print(full=False)}")
    del queues[callback_query.message.chat.id][qname]


@dp.callback_query_handler(lambda c: c.data and c.data.startswith('reset'))
async def insert_in_queue(callback_query: types.CallbackQuery):
    _, qname = callback_query.data.split("/")
    if callback_query.from_user.id != queues[callback_query.message.chat.id][qname].creator and callback_query.from_user.id != BOT_CREATOR:
        await bot.answer_callback_query(callback_query.id, text="–≠—Ç–æ –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å —Ç–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å –æ—á–µ—Ä–µ–¥–∏")
        return

    is_modified = queues[callback_query.message.chat.id][qname].reset()
    if is_modified:
        await bot.edit_message_text(message_id=callback_query.message.message_id,
                                    chat_id=callback_query.message.chat.id,
                                    text=f"{qname}:\n{queues[callback_query.message.chat.id][qname].get_print()} \n\
                                    (Generated by {CAN_CREATE_QUEUES[queues[callback_query.message.chat.id][qname].creator].description})",
                                    reply_markup=queues[callback_query.message.chat.id][qname].get_keyboard())
    else:
        await bot.answer_callback_query(callback_query.id, text="–û—á–µ—Ä–µ–¥—å –∏ –±—ã–ª–∞ –ø—É—Å—Ç–∞")


executor.start_polling(dp, skip_updates=True)
