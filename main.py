import asyncio
from aiogram import Bot, Dispatcher, executor, types
from aiogram.types import InlineKeyboardButton
from aiohttp import ClientSession
import user_queue
import pickle
from chkmsg import *
from load_env import API_TOKEN, GOOGLE_TOKEN
from config import BOT_CREATOR, CAN_CREATE_QUEUES, CHAT_IDS, DEFAULT_QUEUE_SIZE, MAX_QUEUE_NAME_LENGTH, URLS, MAX_QUEUE_SIZE

with open("queues.txt", "rb") as f:
    queues = pickle.load(f)

queues: dict[int, dict[str, user_queue.Queue]] = queues

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)


@dp.message_handler(commands=["myid"])
async def my_id(message: types.Message):
    ans = f"Your id: ***`{message.from_user.id}`***\nThis chat id: ***`{message.chat.id}`***"
    if message.chat.id in CHAT_IDS.keys():
        ans += f" \\(defined as {CHAT_IDS[message.chat.id]}\\)"
    if message.from_user.id in CAN_CREATE_QUEUES.keys():
        ans += f"\nYou can create queues"
    await message.answer(ans, parse_mode="MarkdownV2")


@dp.message_handler(commands=["createq", "createqueue", "startq", "startqueue"])
async def create_queue(message: types.Message):
    if message.from_user.id not in CAN_CREATE_QUEUES:
        await message.answer("–¢—ã –Ω–µ –º–æ–∂–µ—à—å —Å–æ–∑–¥–∞—Ç—å –æ—á–µ—Ä–µ–¥—å")
        return
    if len(message.text.split()) < 2:
        await message.answer("Usage: /createqueue <size, default=25> <qname>")
        return
    try:
        size = min(int(message.text.split()[1]), MAX_QUEUE_SIZE)
        _, qname = message.text.split(maxsplit=2)[1:]
    except ValueError:
        qname = message.text.split(maxsplit=1)[1]
        size = DEFAULT_QUEUE_SIZE

    if message.chat.id not in queues.keys():
        queues[message.chat.id] = {}

    if qname in queues[message.chat.id].keys():
        await message.answer("–≠—Ç–∞ –æ—á–µ—Ä–µ–¥—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
        return
    if '/' in qname:
        await message.answer("–ù–µ –¥–æ–±–∞–≤–ª—è–π / –≤ –Ω–∞–∑–≤–∞–Ω–∏–µ –æ—á–µ—Ä–µ–¥–∏")
        return
    if len(qname) > MAX_QUEUE_NAME_LENGTH:
        await message.answer("–°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ")
        return

    buttons = [InlineKeyboardButton(str(num) + "üü¢", callback_data=f"key/{num - 1}/{qname}") for num in
               range(1, size + 1)]
    reset_button = InlineKeyboardButton(
        "RESET", callback_data=f"reset/{qname}")
    stop_button = InlineKeyboardButton("STOP", callback_data=f"stop/{qname}")
    queues[message.chat.id][qname] = user_queue.Queue(message.from_user.id, [buttons, reset_button, stop_button],
                                                      size=size)
    await message.answer(
        f"{qname}:\n{queues[message.chat.id][qname].get_print()} \n(Generated by {CAN_CREATE_QUEUES[message.from_user.id].description})",
        reply_markup=queues[message.chat.id][qname].get_keyboard())


@dp.message_handler(commands=["getqueue"])
async def get_queue_from_google(message: types.Message):
    if message.from_user.id not in CAN_CREATE_QUEUES:
        await message.answer("–¢—ã –Ω–µ –º–æ–∂–µ—à—å —Å–æ–∑–¥–∞—Ç—å –æ—á–µ—Ä–µ–¥—å")
        return
    if message.chat.id not in URLS.keys():
        await message.answer("–≠—Ç–æ—Ç —á–∞—Ç –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω")
        return
    msg = "–ò–∑ —Ç–∞–±–ª–∏—á–∫–∏:\n"
    async with ClientSession() as session:
        async with session.get(URLS[message.chat.id]) as response:
            values = (await response.json()).get("values")

            for time, name, group, labwork_id in values:
                msg += f"{labwork_id: <3} {name} ({time})\n"

    await message.answer(text=msg)


@dp.message_handler(commands=["delaystartq"])
async def delay_create_queue(message: types.Message):
    if message.from_user.id not in CAN_CREATE_QUEUES:
        await message.answer("–¢—ã –Ω–µ –º–æ–∂–µ—à—å —Å–æ–∑–¥–∞—Ç—å –æ—á–µ—Ä–µ–¥—å")
        return
    if len(message.text.split()) < 2:
        await message.answer("Usage: /delaystartq t=<await time> <delay, default=10> <qname>")
        return
    time = 10
    if message.text.split()[1].startswith('t='):
        time = int(message.text.split()[1][2:])
        if time < 0:
            await message.answer("–ó–∞–¥–µ—Ä–∂–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–π")
            return
        message.text = message.text.replace(message.text.split()[1] + " ", "")

    SLEEP_TIME = 10
    start_time = time

    callback_query = await message.answer(f"–û—á–µ—Ä–µ–¥—å –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è —á–µ—Ä–µ–∑ {time} —Å–µ–∫")
    while True:
        await asyncio.sleep(min(SLEEP_TIME, time))
        time -= SLEEP_TIME
        if time <= 0:
            break
        await bot.edit_message_text(message_id=callback_query.message_id, chat_id=callback_query.chat.id,
                                    text=f"–û—á–µ—Ä–µ–¥—å –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è —á–µ—Ä–µ–∑ {time} (start={start_time}) —Å–µ–∫")
    await create_queue(message)
    await bot.edit_message_text(message_id=callback_query.message_id, chat_id=callback_query.chat.id,
                                text=f"–û—á–µ—Ä–µ–¥—å –∑–∞–ø—É—â–µ–Ω–∞!")


@dp.message_handler(commands=["listq"])
async def queue_list(message: types.Message):
    if message.from_user.id != BOT_CREATOR:
        await message.answer("Only for Hu Tao")
        return

    msg = "–û—á–µ—Ä–µ–¥–∏:\n"
    for (chat_id, queues_list) in queues.items():
        msg += f"{CHAT_IDS.get(chat_id, chat_id)}:\n"
        for name in queues_list.keys():
            msg += f"{name}\n"
        msg += "\n"

    await message.answer(text=msg)


@dp.message_handler(commands=["delete"])
async def delete(message: types.Message):
    if message.from_user.id != BOT_CREATOR:
        await message.answer("Only for Hu Tao")
        return

    for i in list(queues[message.chat.id].keys()):
        del queues[message.chat.id][i]
    await message.answer(text="Done")


@dp.message_handler(commands=["deleteall"])
async def delete_all(message: types.Message):
    if message.from_user.id != BOT_CREATOR:
        await message.answer("Only for Hu Tao")
        return

    for i in list(queues.keys()):
        del queues[i]
    await message.answer(text="Done")


@dp.message_handler(commands=["me"])
async def me(message: types.Message):
    if len(message.text.split()) < 4 and message.from_user.id != BOT_CREATOR:
        await message.answer("Usage: /me –§–∞–º–∏–ª–∏—è –ò–º—è –û—Ç—á–µ—Å—Ç–≤–æ")
        return

    try:
        user = message.text.split(maxsplit=1)[1]
    except IndexError:
        user = '–Ø–≥–æ–¥–∏–Ω –ó–∞—Ö–∞—Ä –°–µ—Ä–≥–µ–µ–≤–∏—á'

    async def get_data(user: str, table: str, tab: str, start: str, end: str, ):
        async def generate_url():
            URL_TEMPLATE = f"https://sheets.googleapis.com/v4/spreadsheets/" \
                           f"{table}/values/" \
                           f"{tab}!{start}:{end}?" \
                           f"key={GOOGLE_TOKEN}"
            async with ClientSession() as session:
                async with session.get(URL_TEMPLATE) as response:
                    return (await response.json()).get("values")

        values = await generate_url()
        values = values[0], [i for i in values[1:] if user in i][0]
        values = list(map(list, zip(*values)))
        values = [[i, j] for (i, j) in values if i in [
            "–ò—Ç–æ–≥–æ", "–ò—Ç–æ–≥ —Ñ—É–ª–ª", 'Total', 'Mid term score']]
        return values[0][1]

    tables = {
        "programming": ["1RDy1Fs8YmFQ7siXtub1wGKU5nnHTwHn6soBA4FvtPno", "–ë–∞–ª–ª—ã", "A3", "Q"],
        "algorithms": ["1UlkxAJ_PHAWjLDrZQYVE5Z_xjdaj1_9l1QnAmjyMdEI", "—Å–µ–º–µ—Å—Ç—Ä 1", "A", "U"],
        "discrete": ["1b202IiOF_Q11qLv8iVbJHKckKOaE1tPnNrSCmUYpjW4", "Scores", "A3", "P"],
        "english (p1)": ["1NMf94E2Gv7gCe5bc5-BIj2afmoh2uqlMeqKnnZKE2G0", "Fall semester (weeks1-8)", "A2", "AE"],
        "english (p2)": ["1NMf94E2Gv7gCe5bc5-BIj2afmoh2uqlMeqKnnZKE2G0", "Fall semester (weeks9-16)", "A2", "AG"],
    }

    msg = f"{user}\n"
    for table, tab in tables.items():
        msg += f"{table}:\n"
        try:
            msg += f"Total: {await get_data(user, *tab)}\n"
        except IndexError:
            msg += "Not found\n"
        msg += "\n"
    await message.answer(text=msg)


@dp.message_handler(commands=["shutdown", "exit"])
async def shutdown(message: types.Message):
    if message.from_user.id != BOT_CREATOR:
        await message.answer("Only for Hu Tao")
        return

    dp.stop_polling()
    pickle.dump(queues, open("queues.txt", "wb"))
    exit()


@dp.callback_query_handler(lambda c: c.data and c.data.startswith('key'))
async def insert_in_queue(callback_query: types.CallbackQuery):
    _, code, qname = callback_query.data.split("/")
    code = int(code)
    user_id = callback_query.from_user.id
    name = f"{callback_query.from_user.full_name} (@{callback_query.from_user.username})"
    text, code = queues[callback_query.message.chat.id][qname].set(
        code, user_id, name)
    await bot.answer_callback_query(callback_query.id, text=text)
    if code:
        await asyncio.sleep(0.1)
        await bot.edit_message_text(message_id=callback_query.message.message_id,
                                    chat_id=callback_query.message.chat.id,
                                    text=f"{qname}:\n{queues[callback_query.message.chat.id][qname].get_print()} \n(Generated by {CAN_CREATE_QUEUES[queues[callback_query.message.chat.id][qname].creator].description})",
                                    reply_markup=queues[callback_query.message.chat.id][qname].get_keyboard())


@dp.callback_query_handler(lambda c: c.data and c.data.startswith("stop"))
async def delete_queue(callback_query: types.CallbackQuery):
    _, qname = callback_query.data.split("/")
    if qname not in queues[callback_query.message.chat.id].keys():
        await bot.edit_message_text(message_id=callback_query.message.message_id,
                                    chat_id=callback_query.message.chat.id,
                                    text=f"{qname} (stopped)")
        return

    if callback_query.from_user.id != queues[callback_query.message.chat.id][qname].creator and callback_query.from_user.id != BOT_CREATOR:
        await bot.answer_callback_query(callback_query.id, text="–≠—Ç–æ –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å —Ç–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å –æ—á–µ—Ä–µ–¥–∏")
        return

    await bot.edit_message_text(message_id=callback_query.message.message_id, chat_id=callback_query.message.chat.id,
                                text=f"{qname} (stopped):\n{queues[callback_query.message.chat.id][qname].get_print(full=False)}")
    del queues[callback_query.message.chat.id][qname]


@dp.callback_query_handler(lambda c: c.data and c.data.startswith('reset'))
async def reset_queue(callback_query: types.CallbackQuery):
    _, qname = callback_query.data.split("/")
    if callback_query.from_user.id != queues[callback_query.message.chat.id][qname].creator and callback_query.from_user.id != BOT_CREATOR:
        await bot.answer_callback_query(callback_query.id, text="–≠—Ç–æ –º–æ–∂–µ—Ç —Å–¥–µ–ª–∞—Ç—å —Ç–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å –æ—á–µ—Ä–µ–¥–∏")
        return

    is_modified = queues[callback_query.message.chat.id][qname].reset()
    if is_modified:
        await bot.edit_message_text(message_id=callback_query.message.message_id,
                                    chat_id=callback_query.message.chat.id,
                                    text=f"{qname}:\n{queues[callback_query.message.chat.id][qname].get_print()} \n(Generated by {CAN_CREATE_QUEUES[queues[callback_query.message.chat.id][qname].creator].description})",
                                    reply_markup=queues[callback_query.message.chat.id][qname].get_keyboard())
    else:
        await bot.answer_callback_query(callback_query.id, text="–û—á–µ—Ä–µ–¥—å –∏ –±—ã–ª–∞ –ø—É—Å—Ç–∞")


@dp.message_handler()
async def echo(message: types.Message):
    if check_message(message):
        pass


executor.start_polling(dp, skip_updates=True)
